---
title: "RNA-Seq1"
author: "Ivan Trus"
date: "2022-12-07"
output: html_document
---
# Initialization

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = TRUE,
	warning = TRUE
)
StartTime <- Sys.time()

library(magrittr)
library(dplyr)
library(janitor)
library(readr)
library(RColorBrewer)
library(DT)

# installing required Bioconductor packages
# uncomment these lines and run them once if you still don't have these required packages
# install.packages("BiocManager")
# BiocManager::install("biomaRt")
# BiocManager::install("tximport")
# BiocManager::install("edgeR")
# BiocManager::install("limma")
# BiocManager::install("rhdf5")

library(biomaRt)
library(tximport)
library(edgeR)
library(rhdf5)
```

# Importing Data from BioMART
This block creates database of Genes and Transcripts called Tx2Gen. It will be created once and loaded later in the following R script. You can create database once and to use it repeatedly. Comment this block and uncomment the line below to load the previously created Tx2Gen.Rdata file. Searching string "GRCh38.p13" corresponds to the current version of human BioMart.
```{r importing Transcripts database}
# AvailableBioMart <- searchDatasets(mart = useMart("ensembl"))
# DT::datatable(as.data.frame(AvailableBioMart),
#   caption = "Available BioMarts", options = list(pageLength = 10))
# SearchedBiomart <- "GRCh38.p13"
# print(paste("We are searching for:", SearchedBiomart))
# print("We found:")
# FoundBioMart <- searchDatasets(mart = useMart("ensembl"), pattern = SearchedBiomart)
# print(FoundBioMart)
# stopifnot("Number of found BioMarts is not equal one" = dim(FoundBioMart[1]) == 1)
# stopifnot("Wrong BioMart was found" = FoundBioMart[3] == SearchedBiomart)
# Tx2Gen <- getBM(attributes = c("ensembl_transcript_id", "transcript_version",
#                                "ensembl_gene_id", "external_gene_name",
#                                "description", "transcript_biotype",	"transcript_length"),
#                 mart = (useMart(biomart = "ENSEMBL_MART_ENSEMBL",
#                                 dataset = FoundBioMart[1])))
# saveRDS(Tx2Gen, "Tx2Gen.Rdata")

Tx2Gen <- readRDS("Tx2Gen.Rdata")
```

# Importing Kallisto results
Important! No extra subfolders or files should be in the folder with the results.
```{r importing reads}
FolderWithKallistoData <- "kallisto"

SampleId <- dir(FolderWithKallistoData)
Files <- file.path(FolderWithKallistoData, SampleId, "abundance.h5")
names(Files) <- SampleId
DT::datatable(as.data.frame(Files), caption = "List of files",
              options = list(pageLength = 100))
KallistoData <- tximport(Files, type = "kallisto",
                         tx2gene = rename(Tx2Gen[, c(1, 3)],
                                          target_id = ensembl_transcript_id,
                                          ens_gene = ensembl_gene_id),
                         ignoreTxVersion = T)
print(paste(length(Files), "files loaded from the '",
            FolderWithKallistoData , "' folder."))
summary(KallistoData$counts)

# Combining IDs from Kallisto and ENSEMBL
GeneExpression <- DGEList(KallistoData$counts)
GeneId <- as.data.frame(rownames(GeneExpression))
names(GeneId) <- "GeneId"
Genes <- merge(GeneId, distinct(Tx2Gen[, c(3:7)], ensembl_gene_id, .keep_all = T),
               by.x = "GeneId", by.y = "ensembl_gene_id", all.x = T)
GeneExpression$genes <- Genes
```

# Attaching the table with Metadata.
Adding factors from RunTable.txt. First column contains sample names, the second one is group allocation, the following are factors from the study. It is important to have samples arranged in the same order (alphabetically) as folders coming with Kallisto results.

Please check carefully if everything is correct with the imported samples names and factors.
```{r metadata}
Samples <- read.delim("RunTable.txt", sep = ",", stringsAsFactors = F) %>% clean_names()
stopifnot("Samples order in RunTable.txt isn't the same as in the folder with
          the Kallisto results" = rownames(GeneExpression$samples) == Samples[1])
GeneExpression$samples$group <- Samples$group
GeneExpression$samples <- cbind(GeneExpression$samples, Samples[ , -1:-2])
DT::datatable(as.data.frame(GeneExpression$samples),
  caption = "Samples Metadata", options = list(pageLength = 100))
```

# Cleaning the dataset
```{r Cleaning the dataset}
# Transformation to CPM and deleting low CPM genes
CopiesPerMillion <- cpm(GeneExpression, log = T)
print(paste(dim(GeneExpression)[1], "genes in total were identified by Kallisto"))
nsamples <- ncol(CopiesPerMillion)
color <- brewer.pal(nsamples, "Paired")
par(mfrow=c(1,2))

plot(density(CopiesPerMillion[ , 1]), col = color[1], lwd = 2, xlim = c(-5, 10),
     main = "CPM before cut-off", xlab = "CPM, log2")
abline(v = log2(1), lty = 3)
for (i in 2:nsamples){
  lines(density(CopiesPerMillion[, i])$x,
        density(CopiesPerMillion[, i])$y,
        col = color[i], lwd = 2)
}
legend("topright", rownames(GeneExpression$samples), text.col=color, bty="n",
       cex = 0.5, text.font = 2)

#GeneExpression <- GeneExpression[rowSums(CopiesPerMillion > 1) >= 3, keep.lib.sizes = F]
GeneExpression <- GeneExpression[filterByExpr(GeneExpression), , keep.lib.sizes = F]
print(paste(dim(GeneExpression)[1], "genes with CPM values valid for statistical analysis (non-zero level for any given group)"))

CopiesPerMillion <- cpm(GeneExpression, log = T)
plot(density(CopiesPerMillion[ , 1]), col = color[1], lwd = 2, xlim = c(-5, 10),
     main = "CPM after cut-off", xlab = "CPM, log2")
abline(v = log2(1), lty = 3)
for (i in 2:nsamples){
  lines(density(CopiesPerMillion[, i])$x,
        density(CopiesPerMillion[, i])$y,
        col = color[i], lwd = 2)
}
legend("topright", rownames(GeneExpression$samples), text.col=color, bty="n",
       cex = 0.5, text.font = 2)

# Saving the full dataset
saveRDS(GeneExpression, "GE.Rdata")
write.csv(GeneExpression, file = "GE.csv")
```

**Execution start time:** *`r StartTime`*  
**Execution end time  :** *`r Sys.time()`*
